# Ecma 6

## Что такое ecma 6

Ecma 6 - это новый стандарт языка JavaScript, который был принят в 2015 году. Ecma 6 включает в себя множество новых возможностей, которые значительно упрощают разработку приложений на JavaScript. Ecma 6 включает в себя новые возможности, такие как классы, стрелочные функции, шаблонные строки, деструктуризация, генераторы, модули и многое другое.

<br/>

## const и let

В Ecma 6 появились новые ключевые слова для объявления переменных: `const` и `let`. Переменные, объявленные с помощью `const`, не могут быть переназначены, а переменные, объявленные с помощью `let`, могут быть переназначены.

```js
// Объявление переменной с помощью const
const name = "John";

// Объявление переменной с помощью let
let age = 30;
```

<br/>

## Стрелочные функции

Стрелочные функции - это новый синтаксис для определения функций в JavaScript. Они предоставляют более короткий и более читаемый синтаксис, чем обычные функции. Стрелочные функции не имеют собственного контекста выполнения, поэтому они не могут использоваться как методы объекта или конструкторы.

```js
// Обычная функция
function sum(a, b) {
  return a + b;
}

// Стрелочная функция
const sum = (a, b) => a + b;
```

<br/>

## Дефолтные параметры

Дефолтные параметры - это новый синтаксис для определения параметров функции по умолчанию. Они позволяют вам определять значения параметров по умолчанию, которые будут использоваться, если функция вызывается без аргументов.

```js
// Обычная функция
function sum(a, b) {
  if (a === undefined) {
    a = 0;
  }

  if (b === undefined) {
    b = 0;
  }

  return a + b;
}

// Функция с дефолтными параметрами
const sum = (a = 0, b = 0) => a + b;
```

<br/>

## Шаблонные строки

Шаблонные строки - это новый синтаксис для создания строк в JavaScript. Они позволяют вам вставлять значения переменных внутри строки, используя синтаксис `${}`. Шаблонные строки могут быть многострочными и могут содержать выражения JavaScript.

```js
// Обычная строка
const name = "John";
const message = "Hello, " + name + "!";
console.log(message); // Hello, John!

// Шаблонная строка
const name = "John";
const message = `Hello, ${name}!`;
console.log(message); // Hello, John!
```

<br/>

## Spread оператор или оператор расширения

Spread оператор - это новый синтаксис для расширения массивов и объектов. Он позволяет вам расширять массивы и объекты, используя синтаксис `...`. Spread оператор может быть использован для расширения массивов и объектов, а также для создания новых массивов и объектов из расширенных массивов и объектов.

```js
// Расширение массива
const numbers = [1, 2, 3, 4, 5];
const newNumbers = [...numbers, 6, 7, 8, 9, 10];
console.log(newNumbers); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

// Расширение объекта
const user = {
  name: "John",
  age: 30,
};

const newUser = {
  ...user,
  email: "john@domain.com",
};

console.log(newUser); // { name: "John", age: 30, email: " }
```

<br/>

## Деструктуризация

Деструктуризация - это новый синтаксис для извлечения значений из объектов и массивов. Он позволяет вам извлекать значения из объектов и массивов, используя синтаксис `{}` и `[]`. Деструктуризация может быть использована для извлечения значений из объектов и массивов, а также для создания новых переменных из значений, извлеченных из объектов и массивов.

```js
// Деструктуризация объекта
const user = {
  name: "John",
  age: 30,
};

const { name, age } = user;

console.log(name); // John
console.log(age); // 30

// Деструктуризация массива
const numbers = [1, 2, 3, 4, 5];

const [first, second, ...rest] = numbers;

console.log(first); // 1
console.log(second); // 2
console.log(rest); // [3, 4, 5]
```

<br />
<br />
<br />

# Реактивность

## Что такое реактивность

В JavaScript реактивность - это концепция, которая позволяет автоматически обновлять данные и пользовательский интерфейс при изменении исходных данных. Она основана на принципе "отслеживания зависимостей", то есть система сама определяет, какие значения зависят от других, и обновляет их при изменении.

Реактивность в JavaScript описывает способность системы или фреймворка автоматически обновлять данные и пользовательский интерфейс при изменении исходных данных. Она позволяет создавать динамические и отзывчивые веб-приложения, где изменения данных автоматически отражаются на пользовательском интерфейсе без необходимости явного вмешательства программиста.

<br/>

## State management

Стейт менеджмент в JavaScript — это практика управления состоянием (state) приложения. Состояние представляет собой данные, которые определяют текущее состояние приложения и влияют на его поведение и отображение пользовательского интерфейса.

<br />
<br />
<br />

## Задача 1

Реализовать приложение для отображения и добавления фильмов с рейтингами.

- Создать экземпляр класса State с начальным состоянием { films: [] }. Этот экземпляр будет представлять состояние фильмов в приложении.
- Найти элемент с классом.films и сохранить его в переменной films.
- Создать функцию renderFilms, которая будет отображать фильмы на странице на основе текущего состояния filmsState.

  - Очистить содержимое элемента films.
  - Если в состоянии filmsState нет фильмов (filmsState.state.films.length === 0), вывести сообщение "No films" внутри элемента films.
  - Для каждого фильма в состоянии filmsState:
  - Создать элемент div с классом .film.
  - Создать элемент span для названия фильма и установить его текстовое содержимое равным film.title.
  - Создать элемент span для рейтинга фильма и установить его текстовое содержимое равным film.rating.
  - Добавить элементы span внутрь элемента div.
  - Добавить элемент div внутрь элемента films.
  - Зарегистрировать функцию renderFilms как слушатель состояния filmsState с помощью метода subscribe. Это гарантирует вызов renderFilms при обновлении состояния фильмов.

- Создать функцию renderAvgRating, которая будет отображать средний рейтинг фильмов на странице на основе текущего состояния filmsState.
  - Найти элемент с классом .avg-rating и сохранить его в переменной avgRating.
  - Если в состоянии filmsState нет фильмов (filmsState.state.films.length === 0), очистить содержимое элемента avgRating.
  - Иначе:
  - Вычислить общую сумму рейтингов фильмов с помощью метода reduce и сохранить результат в переменной totalRating.
  - Вычислить средний рейтинг фильмов, разделив totalRating на количество фильмов в состоянии filmsState и сохранить результат в переменной avg.
  - Установить текстовое содержимое элемента avgRating в формате "Average rating: {avg.toFixed(2)}".
  - Вызвать функцию renderFilms один раз для инициализации отображения фильмов на странице.

[Пример](/examples/07-ecma6-reactivity/example-1)

```html
<main>
  <h1>Film list</h1>

  <div class="avg-rating"></div>

  <div class="films"></div>

  <div class="add">
    <input type="text" id="title" placeholder="Title" />

    <input type="text" id="rating" placeholder="Rating" />

    <button id="add">Add</button>
  </div>
</main>
```

```css
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

html,
body {
  height: 100%;
  width: 100%;
  display: flex;
}

main {
  display: flex;
  flex-direction: column;
  padding: 16px;
  width: 100%;
  gap: 24px;
}

h1 {
  margin: 0;
}

.films {
  display: flex;
  flex-direction: column;
  padding: 8px;
  gap: 16px;
  border: 1px solid black;
}

.film {
  display: flex;
  justify-content: space-between;
  border-bottom: 1px solid black;
  padding-bottom: 4px;
}

.add {
  display: flex;
  flex-direction: column;
  width: 300px;
  padding: 4px;
  gap: 8px;
  border: 1px solid black;
}

input {
  font-size: 24px;
  padding: 4px 6px;
}

button {
  font-size: 24px;
  padding: 4px 6px;
}
```

```js
const filmsState = new State({
  films: [],
});

const films = document.querySelector(".films");

const renderFilms = () => {}; // Функция для отрисовки фильмов

filmsState.subscribe(renderFilms); // Подписываемся на изменения в стейте

renderFilms(); // Изначальная отрисовка фильмов

const renderAvgRating = () => {};

filmsState.subscribe(renderAvgRating);

renderAvgRating();
```
